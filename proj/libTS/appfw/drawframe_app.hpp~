/* -*-tab-width:4-*-
   libTS appfw.hpp
 */
#ifndef TS_APPFW_APPFW_HPP
#define TS_APPFW_APPFW_HPP


#include <stdint.h>
#include <iostream>
#include <string>
#include <queue>
#include <stdexcept>
#include <boost/shared_ptr.hpp>

#include "libTS/Util/Logger.h"
#include "exception.hpp"
#include "inputfw.hpp"
#include "gl/glfw.hpp"
#include "sound/soundfw.hpp"

namespace ts {
namespace appfw {
  // application framework
  using namespace std;

  typedef boost::mutex::scoped_lock scoped_lock;

  struct app_info {
	typedef boost::shared_ptr<app_info> ptr;
	vector<string> args_;
	string app_name_;
	string app_dir_; // アプリケーションのディレクトリ
	string res_dir_; // リソースのディレクトリ
	string doc_dir_; // アプリケーションドキュメントのディレクトリ
	string platformName_;
  };

  // アプリケーションフレームワークのベースクラス
  class app_framework {
  protected:
	
	app_info::ptr app_info_;
	event::event_handler input_eh_; // 入力デバイスのイベントハンドラ
  public:
	sounds::audio_ctrl& audio_;
	sounds::music_player music_;
	sounds::sound_player sound_;

  protected:
	app_framework() 
	  : audio_(sounds::audio_ctrl::instance()) 
	  , music_(audio_)
	  , sound_(audio_)

	{}
	virtual ~app_framework() throw() {}

  public:
	// フレームワークがアクセスするアプリケーションインスタンス
	static app_framework& app_instance();

	// 初期化
	void initialize(app_info::ptr info) {
	  app_info_ = info;
	  initialize_impl();
	}

	// サウンドリソースファイルのリストを取得する
	virtual void get_sound_list(std::vector<std::string>&) {}
	virtual void get_music_list(std::vector<std::string>&) {}
	

	// Audioコントロールのフック
	void audio_control_hook(std::vector<sounds::audio_param>& list) {
      sounds::audio_ctrl::instance().control_hook(list);
	}

	// 演奏中の音楽の再生時間を設定する
	// 実行環境のスレッドで呼ばれる
	void set_current_music_time(float tim) {
	  music_.current_music_time_ = tim;
	}

	// アップデート通知
	virtual void update() {}

	// 入力フレームワークへのアクセス
	in::event_handler& input_eh() {
	  return input_eh_;
	}
	
	// イベント通知
	// 環境依存のスレッドから呼ばれる
	template <typename Ctrl>
	void notify_event(const Ctrl& ctrl, uint32_t devnum=0) {
	  input_eh_.notify_event(ctrl, devnum);
	}

	// イベント処理
	//  appfwのスレッドで実行される
	void process_events() {
	  while (input_eh_.execute(*this));
	}
	// イベント処理ルーチン
	//  appfwのスレッドで実行される
	void operator () (event::event_t::ptr ev) {
	  event::event_processor::ptr e = event_handling_impl(ev);
	  // イベント処理したオブジェクトがある場合、通知する
	  if (e) {
		on_event_proseeded(e);
	  }
	}

	// サービスメソッド
	const string& application_dir() const { return app_info_->app_dir_; }
	const string& documentation_dir() const { return app_info_->doc_dir_; }
	const string& resource_dir() const { return app_info_->res_dir_; }
	
  protected:
	// イベント処理ルーチン
	// appfwのスレッドで実行される
	virtual void initialize_impl() = 0;

	// イベント処理ルーチン
	//  appfwのスレッドで実行される
	virtual event::event_processor::ptr event_handling_impl(event::event_t::ptr ev) {
	  switch (ev->device_type()) {
	  case event::tap_device:
		on_tap_ctrl(boost::static_pointer_cast<in::tap_event>(ev));
		break;
	  case event::acc_device:
		on_acc_ctrl(boost::static_pointer_cast<in::acc_event>(ev));
		break;
	  default:
		break;
	  }
	  return event::event_processor::ptr();
	}

	// イベントが処理された事の通知
	//  appfwのスレッドで実行される
	virtual void on_event_proseeded(event::event_processor::ptr) {}

	virtual void on_tap_ctrl(in::tap_event::ptr evt) {
	  TS_DEBUGLOG("on_tap_ctrl(#%d, act:%d, (%.2f,%.2f)\n"
				  , evt->devnum_
				  , evt->ctrl_.action_
				  , evt->ctrl_.pos_.x_
				  , evt->ctrl_.pos_.y_);
	}
	
	virtual void on_acc_ctrl(in::acc_event::ptr evt) {
	  TS_DEBUGLOG("on_acc_ctrl(#%d, (%.2f,%.2f,%.2f)\n"
				  , evt->devnum_
				  , evt->ctrl_.acc_.x_
				  , evt->ctrl_.acc_.y_
				  , evt->ctrl_.acc_.z_);

	}
	
	
  };



	


  // DrawFrame毎に呼び出されるタイプのアプリケーション
  class drawframe_app : public app_framework {
	uint32_t numOfBuffers_;
  protected:
	virtual ~drawframe_app() throw() {}

  public:	
	gl::glfw gr_;
	
	
	enum thread_status {
	  unintialized,
	  running,
	  stopped
	};
	volatile thread_status        threadStatus_;
	boost::mutex                      ef_guard_;
	boost::condition_variable_any     wakeup_;
	boost::thread mainthread_;
	volatile uint32_t frame_counter_;
	
	
  protected:
	drawframe_app()
	  : numOfBuffers_(2)
	  , threadStatus_(unintialized)
	  , mainthread_(boost::ref(*this))
	  , frame_counter_(0)
	{}

	virtual event::event_processor::ptr event_handling_impl(event::event_t::ptr ev) {
	  event::event_processor::ptr e = gr_(ev);
	  if (e) return e;
	  return app_framework::event_handling_impl(ev);
	}

  protected:
	virtual void initialize_impl() {
	  // スレッド起動
	  threadStatus_ = running;
	}
	// メインルーチン
	virtual void main() = 0;

  public:
	
	// 描画処理
	void swap_buffers() {
	}

	// アップデート通知
	virtual void update() {
	  gr_.update();
	}



	// 描画フレーム開始のフック
	// 実行環境のフレームワークから毎フレーム呼び出される。
	void draw_frame_hook(float timestamp) {
	  gr_.drawframe();
	  {
		scoped_lock lk(ef_guard_);
		wakeup_.notify_one();
	  }
	  ++frame_counter_;
	}

	uint32_t frame_counter() const { return frame_counter_; }

	
	bool is_running() const {
	  return threadStatus_ == running;
	}
	bool is_stopped() const {
	  return threadStatus_ == stopped;
	}
	
	void wait_for_sec(float second) {
	  wait_for_frame(static_cast<uint32_t>(second * 60));
	}
	
	void wait_for_frame(uint32_t frames=1) {
	  while (frames--) {
		// イベント処理
		process_events();
		scoped_lock lk(ef_guard_);
		// 現在の60秒後の時間を計算
		boost::xtime xt;
		boost::xtime_get(&xt, boost::TIME_UTC);
		xt.sec += 60;
		if (!wakeup_.timed_wait(lk, xt)) {
		  // タイムアウトした！
		  on_drawframe_timeout();
		}
	  }
	  return;
	}
	
	// スレッドのメインルーチン
  public:
	void operator()() {
	  // 基本的に無限ループしておく
	  for(;;) {
		switch (threadStatus_) {
		case unintialized:
		  wait_for_frame();
		  break;
		case running:
		  main();
		  threadStatus_ = stopped;
		  break;
		case stopped:
		default:
		  return;
		};
	  }
	}
	
	// イベント
	
	// 描画が行われない
	virtual void on_drawframe_timeout() {
	  TS_DEBUGLOG("drawframe wait timeout");
	  throw drawframe_exception("drawframe wait timeout");
	}


	// フレームワークがアクセスするアプリケーションインスタンス
	static drawframe_app& app_instance();
  };
  

} // namespace appfw
} // namespace ts

#endif
