/* -*-tab-width:4-*- *  CircuitTimer.hpp *  CircuitTimer * *  Created by IKEDA KOHEI on 2010/09/01. *  Copyright 2010 SoftwareSoietyAkihabara. All rights reserved. * */#ifndef TS_CIRCUITTIMER_HPP#include <sys/time.h>#include <stdint.h>#include <vector>#include <string>#include <assert.h>#include "libTS/Util/serialize_policy.hpp";#include "libTS/Util/TimeParam.hpp";#include "ActionLog.hpp"#include "RiderInfo.hpp"#include "RaceInfo.hpp"#include "TeamInfo.hpp"#include "StintInfo.hpp"namespace circuit_timer {  using namespace ts;  class CircuitTimer {  public:	enum StatusType {	  NotStarted,	  Started,	  PitStoped,	  Finished	};	static const uint32_t MaxStintNum  = 32; // スティントの最大数	//////////////////////////////////////////////////////////////	/// CircuitTimer	CircuitTimer()	  : startTime_(1)	  , stopTime_(1)	  , lapCount_(0)	  , status_(NotStarted)	  , rider_(0)	  , stint_(0)	  , immidiateMode_(false)	  , currentLapTime_(0)	{	  riderData_.push_back(RiderInfo("五十嵐　聡",99, 7.4));	  riderData_.push_back(RiderInfo("池田　公平",103, 8.0));	  riderData_.push_back(RiderInfo("岡吉　智宏",101, 7.9));	  fuelLeft_ = teamInfo_.machineInfo_.fuelCapacity_;	}	static CircuitTimer& Instance() {	  static CircuitTimer instance;	  return instance;	}	// アクセッサ	const RaceInfo& getRaceInfo() const {  return raceInfo_; }	RaceInfo& raceInfo() { return raceInfo_; }	const TeamInfo& getTeamInfo() const {  return teamInfo_; }	TeamInfo& teamInfo() { return teamInfo_; }	uint32_t getNumOfStint() const { return stintList_.size();	}	StintInfo& getStint(uint32_t stint) {	  if (stint >= stintList_.size()) {		static StintInfo si;		si.setInvalid();		return si;	  }	  return stintList_[stint];	}	void clearStint() {	  stintList_.clear();	  calcStint();	}	void startTimer() {	  startTime_ = getNow();	  stopTime_ = 0;	  lapCount_ = 0;	  lastLap_ = startTime_;	  history_.push_back(ActionLog(StartAction, true, startTime_, stint_, rider_, fuelLeft_));	  status_ = Started;	  riderData_[rider_].outLapCount_ += 1;	  stint_ = 0;	  save();	}	void stopTimer() {	  stopTime_ = getNow();	  history_.push_back(ActionLog(StopAction, true, stopTime_, stint_, rider_, fuelLeft_));	  status_ = Finished;	  save();	}	MicroTime lapTimer(ActionType action=LapAction) {	  MicroTime now = getNow();	  MicroTime lapTime = now - lastLap_;	  MicroTime raceTime = now - startTime_;	  if (now < lastLap_) lapTime = 0;	  if (immidiateMode_) {		raceTime = (lastLap_ - startTime_ ) + currentLapTime_;		lapTime = currentLapTime_;		printf("now:%d:%d:%d lastLap:%d:%d:%d current:%d:%d\n"			   , now.hour(), now.min(), now.sec()			   , lastLap_.hour(), lastLap_.min(), lastLap_.sec()			   , currentLapTime_.min_only(), currentLapTime_.sec()			   );	  }	  int currentStint = stint_;	  int currentRider = rider_;	  switch (action) {		// lap action category	  case LapAction:	  case MissLapAction:	  case InLapAction:	  case OutLapAction:		if (status_ == Started) {		  // 走行中のラップ		  if (action == MissLapAction) {			lapTime = 0;		  }		  stintList_[stint_].fullLapTime_ += lapTime;		  stintList_[stint_].fullLapCount_ += 1;		}		else {		  printf("Invalid Status in lapTimer() action==Lap or MissLap but status != Started\n");		}		if (action == InLapAction) {		  status_ = PitStoped;		  riderData_[rider_].inLapCount_ += 1;		}		else {		  status_ = Started;		}		// OutLapAction		if (action == LapAction && history_.size() > 0 			&& (history_.back().act_ == NewStintAction || history_.back().act_ == IllegalPitWorkAction)) {		  action = OutLapAction;		}		++lapCount_;		// ライダーデータの計算		riderData_[rider_].lapCount_ += 1;		// set best lap		if (!lapTime.empty() && (riderData_[rider_].bestLap_.empty() || riderData_[rider_].bestLap_ > lapTime)) {		  riderData_[rider_].bestLap_ = lapTime;		}		// 燃費計算		{		  double fuelused = raceInfo_.circuit_.courseLength_ / stintList_[stint_].assumeFuelCost_;		  fuelLeft_ -= fuelused;		}		break;		  // 停止中からのアクション(通常はピットアウトのみ)	  case NewStintAction:	  case IllegalPitWorkAction:		if (status_ == PitStoped) {		  // PitOUT!		  status_ = Started;		  riderData_[rider_].outLapCount_ += 1;		  if (action == NewStintAction) {			// つぎのスティントに行く			//if (getStint(stint_).fullFuel_) {			//fuelLeft_ = teamInfo_.machineInfo_.fuelCapacity_;			//}			++stint_;			if (stintList_.size() == stint_) {			  stintList_.push_back(makeStintData(stint_, lapCount_));			}			rider_ = stintList_[stint_].rider_;		  }		}		else {		  printf("Invalid Status in lapTimer() action == PitOut but status != PitStopped\n");		}		break;	  default:		printf("Invalid Action in lapTimer()\n");		return 0;	  }	  history_.push_back(ActionLog(action								   , true								   , now								   , currentStint								   , currentRider								   , fuelLeft_								   , raceTime								   , lapTime								   , lapCount_));	  if (action != MissLapAction) {		if (immidiateMode_) {		  lastLap_ += currentLapTime_;		  printf("%llu\n", lastLap_.mtime_);		}		else {		  lastLap_ = now;		}	  }	  calcStint();	  save();	  return lapTime;	}	MicroTime pitStop() {	  return lapTimer(InLapAction);	}	void missLap() {	  lapTimer(MissLapAction);	}	MicroTime pitOut(bool changeStint) {	  return lapTimer(changeStint ? NewStintAction : IllegalPitWorkAction);	}	void reFuel(double infuel, int lap, bool full=true) {	  // find for lapCount	  uint32_t nowIdx;	  for (nowIdx = 0; nowIdx < history_.size(); ++nowIdx) {		if (history_[nowIdx].isPitStoped() && history_[nowIdx].lapCount_ == lap) break;	  }	  if (nowIdx >= history_.size()) {		printf("Invalit lapCount:%d in reFuel\n", lap);		return;	  }	  uint32_t lastIdx = 0; // last reFuel lap	  for (lastIdx = nowIdx - 1; lastIdx > 0; --lastIdx) {		if (history_[lastIdx].reFuel_ != 0.0) break;	  }	  // calc valid lap count	  int laps = 0;	  for (uint32_t n = lastIdx+1; n < nowIdx; ++n) {		if (history_[n].isRunning()) ++laps;	  }	  double usedFuel = teamInfo_.machineInfo_.fuelCapacity_ - infuel;	  double left = history_[lastIdx].fuelLeft_;	  printf("laps:%d usedFuel:%lf left:%lf\n", laps, usedFuel, left);	  // re-calc fuelLeft every previos laps	  for (uint32_t n = lastIdx+1; n < nowIdx; ++n) {		if (history_[n].isRunning()) left -= usedFuel / laps;		history_[n].fuelLeft_ = left;	  }	  // ピットイン時の残燃料を設定	  history_[nowIdx].fuelLeft_ = teamInfo_.machineInfo_.fuelCapacity_;// - infuel;	  history_[nowIdx].reFuel_ = infuel;	  // 	  if (nowIdx == history_.size()-1) 		fuelLeft_ = teamInfo_.machineInfo_.fuelCapacity_;	  	  double fuelcost = laps * raceInfo_.circuit_.courseLength_ / usedFuel;	  stintList_[history_[nowIdx].stint_].realFuelCost_ = fuelcost;	  printf("fuelCost = %lf\n", fuelcost);	  save();	}	// 直前のピットインの給油量を設定	bool fuelIn(double fuel) {	  if (fuel == 0.0) return false;	  // 最新のピットストップを探す	  for (int n = history_.size()-1; n >= 0; --n) {		if (!history_[n].real_) continue;		if (history_[n].act_ == InLapAction) {		  reFuel(fuel, history_[n].lapCount_);		  return true;		}	  }	  return false;	}	  		MicroTime getTotalTime() {	  if (!stopTime_.empty()) {		return stopTime_ - startTime_;	  }	  else {		return getNow() - startTime_;	  }	}	MicroTime getLapTime() {	  MicroTime now = getNow();	  if (!stopTime_.empty()) {		return stopTime_ - lastLap_;	  }	  else {		if (now < lastLap_) return 0;		return now - lastLap_;	  }	}	uint32_t getLapCount() const { return lapCount_; }	MicroTime getNow() {	  struct timeval tv;	  gettimeofday(&tv, NULL);	  micro_time_t result = tv.tv_sec; 	  result *= 1000000ULL;	  result += tv.tv_usec;	  return result;	}	StatusType getStatus() const { return status_; }	const RiderInfo& getRiderInfo(uint32_t n = 0xffffffff) const {	  if (n == 0xffffffff) {		n = rider_;	  }	  if (n >= riderData_.size()) {		static RiderInfo ri;		ri.setInvalid();		return ri;	  }	  return riderData_[n];	}	RiderInfo& riderInfo(uint32_t rider) {	  return riderData_[rider];	}	uint32_t getHistoryCount() const {	  return static_cast<uint32_t>(history_.size());	}	const ActionLog& getHistory(uint32_t line) const {	  assert(line < history_.size());	  return history_[line];	}	int32_t getLastRealHistory() const {	  if (history_.empty()) return -1;	  for (int32_t n = 0; n < static_cast<int>(history_.size()); ++n) {		if (!history_[n].real_) {		  return n - 1;		}	  }	  return static_cast<int32_t>(history_.size()-1);	}		  	double getFuelLeft() const {	  return fuelLeft_;	}	double getCanLapLeft()  {	  return getCanLapLeft(fuelLeft_, rider_);	}	double getCanLapLeft(double fuel, uint32_t rider) {	  if (stintList_.size() <= stint_) {		calcStint();	  }	  return fuel * stintList_[stint_].assumeFuelCost_ / raceInfo_.circuit_.courseLength_;	}	void setCurrentRider(int rider) {	  printf("CircuitTimer::setCurrentRider(%d)\n", rider);	  if (rider >= riderData_.size()) {		riderData_.resize(rider);	  }	  rider_ = rider;	}	uint32_t getRiders() const { return riderData_.size(); }	void setRiders(int riders) {	  printf("CircuitTimer::setRiders(%d)\n", riders);	  riderData_.resize(riders);	}	uint32_t getCurrentRider() const { return rider_; }	uint32_t updateStint(uint32_t stint, uint32_t rider, uint32_t laps, bool fullFuel, bool changeWheels, double fc, MicroTime at) {	  StintInfo si(stint, rider, laps, fullFuel, changeWheels, fc, at);	  if (stint >= stintList_.size()) {		stint = stintList_.size()-1;		si.num_ = stint;		stintList_.push_back(si);	  }	  else {		stintList_[stint] = si;	  }	  calcStint();	  save();	  return stint;	}	StintInfo makeStintData(uint32_t stint, int32_t startlap) {	  uint32_t rider = stint % riderData_.size();	  return StintInfo(stint					   , rider					   , 0 // laps					   , startlap					   , true  // fuel					   , false // wheel					   , riderData_[rider].fuelCost_					   , riderData_[rider].averageLapTime_);	}	void calcStint() {	  double fuelLeft = teamInfo_.machineInfo_.fuelCapacity_;	  double tire = 0.0;	  	  if (stintList_.empty()) {		stintList_.push_back(makeStintData(0, 1));	  }	  // TODO:実績がある場合はそこから生成する	  uint32_t lastRealLap = 0;	  int32_t lastRealHistory = getLastRealHistory();	  if (lastRealHistory >= 0) {		lastRealLap = history_[lastRealHistory].lapCount_;	  }	  // 実績からスティントを生成	  uint32_t totalLaps = 0;	  uint32_t stintLaps = 0;	  uint32_t startStint = 0;	  uint32_t stint = 0;	  MicroTime best;	  MicroTime totalTime;	  MicroTime stintTime;	  for (uint32_t h = 0; history_.size() > h && h <= lastRealHistory; ++h) {		ActionLog& act = history_[h];		stintList_[stint].status_ = RunningStint;		switch (act.act_) {		case StartAction:		  stintList_[stint].startLap_ = totalLaps+1;		case StopAction:		  break;		case LapAction:		case OutLapAction:		  ++stintLaps;		  ++totalLaps;		  if (best.empty() || best > act.lap_) {			best = act.lap_;		  }		  stintTime += act.lap_;		  fuelLeft = act.fuelLeft_;		  break;		case MissLapAction:		  ++stintLaps;		  ++totalLaps;		  break;		case InLapAction:		  ++stintLaps;		  ++totalLaps;		  totalTime += stintTime;		  stintList_[stint].laps_ = stintLaps;		  stintList_[stint].stintTime_ = stintTime;		  stintList_[stint].totalTime_ = totalTime;		  stintList_[stint].bestLapTime_ = best;		  		  stintList_[stint].averageLapTime_ = stintTime.mtime_ / stintLaps;		  stintList_[stint].fuelLeft_ = act.fuelLeft_;		  stintList_[stint].realFuelCost_ = 			stintLaps * raceInfo_.circuit_.courseLength_ / (fuelLeft - act.fuelLeft_);		  if (stintList_[stint].fullFuel_) {			fuelLeft = teamInfo_.machineInfo_.fuelCapacity_;		  }		  startStint = stint+1;		  break;		case NewStintAction:		  stintList_[stint].status_ = ResultStint;		  ++stint;		  stintLaps = 0;		  best = 0;		  stintTime = 0;		  if (stint >= stintList_.size()) {			stintList_.push_back(makeStintData(stint, totalLaps+1));		  }		  stintList_[stint].startLap_ = totalLaps+1;		  break;		case IllegalPitWorkAction:		  break;		default:		  break;		}	  }	  // ここからは、スティント計画から各ラップを予想	  for (stint = startStint; stint < MaxStintNum; ++stint) {		if (stint == stintList_.size()) {		  // レースが終わっていないのにスティンとが無い場合は追加する　		  stintList_.push_back(makeStintData(stint, totalLaps+1));		  stintList_[stint].status_ = StrategyStint;		}		StintInfo& sinfo = stintList_[stint];		sinfo.num_ = stint;		if (stint == 0 && totalLaps == 0) {		  // 最初のスティントはサイティングラップの処理を行う		  double k = raceInfo_.circuit_.courseLength_ * raceInfo_.sightingLaps_;		  double used = k / teamInfo_.sightingFuelCost_;		  fuelLeft -= used;		  tire += k;		  sightingLapInfo_.length_ = k;		  sightingLapInfo_.usedFuel_ = used;		  sightingLapInfo_.fuelLeft_ = fuelLeft;		  sightingLapInfo_.laps_ = raceInfo_.sightingLaps_;		}		sinfo.stintTime_ = 0;		///printf("Stint:%d laps_:%d\n", stint, sinfo.laps_);		do {		  ++totalLaps;		  ++stintLaps;		  fuelLeft -= raceInfo_.circuit_.courseLength_ / sinfo.assumeFuelCost_;		  tire += raceInfo_.circuit_.courseLength_;		  sinfo.stintTime_ += sinfo.assumeAverageLapTime_;		  //printf("Stint:%d lap:%d fuel:%lf\n", stint, stintLaps, fuelLeft);		}		while (			   (!sinfo.autoLapNum_ || !teamInfo_.isPitInTiming(getCanLapLeft(fuelLeft, sinfo.rider_)))			   && !raceInfo_.isFinishRace(totalLaps, totalTime + sinfo.stintTime_)			   && (sinfo.autoLapNum_ || stintLaps < sinfo.laps_) 			   && totalLaps < 1000			   );		// スティント終了		sinfo.laps_ = stintLaps;		sinfo.fuelLeft_ = fuelLeft;		sinfo.tireUsed_ = tire;		stintLaps = 0;		if (stint != 0) {		  sinfo.stintTime_ += teamInfo_.outLapLossTime_;		}		if (!raceInfo_.isFinishRace(totalLaps, totalTime + sinfo.stintTime_)) {		  // レースは継続		  sinfo.stintTime_ += teamInfo_.inLapLossTime_;		  sinfo.stintTime_ += teamInfo_.pitStopTime_;		  if (sinfo.fullFuel_) {			sinfo.stintTime_ += teamInfo_.withFullFuelTime_;			fuelLeft = teamInfo_.machineInfo_.fuelCapacity_;		  }		  if (sinfo.changeWheels_) {			sinfo.stintTime_ += teamInfo_.withChangeWheelsTime_;			tire = 0.0;		  }			  totalTime += sinfo.stintTime_;		  sinfo.totalTime_ = totalTime;		  printf("Stint%d end: pitStioTime:%.1lf\n", stint, (double)teamInfo_.pitStopTime_);		}		else {		  // finish!		  totalTime += sinfo.stintTime_;		  sinfo.totalTime_ = totalTime;		  stintList_.resize(stint+1);		  break;		}	  }	}	void deleteLastHistory() {	  int32_t lastRealHistory = getLastRealHistory();	  if (lastRealHistory > 0) {		if (lastRealHistory == 0) {		  history_.clear();		}		else {		  history_.resize(lastRealHistory);		  lastLap_ = history_[lastRealHistory-1].ts_;		}	  }	  calcStint();	  save();	}	void setDocumentPath(const char* path) {	  documentPath_ = path;	  printf("DocumentPath=%s\n", path);	}	template<typename T>	void serializeArray(const T& list, FILE* f) {	  fprintf(f, "%u\n", static_cast<uint32_t>(list.size()));	  for (typename T::const_iterator i = list.begin(); i != list.end(); ++i) {		i->serialize(f);	  }	}	template<typename T>	void deserializeArray(T& list, FILE* f) {	  uint32_t count = 0;	  list.clear();	  fscanf(f, "%u\n", &count);	  while (count--) {		typename T::value_type data;		data.deserialize(f);		list.push_back(data);	  }	}	void save(bool latest=true) {	  std::string fn = makeFileName(latest);	  FILE* f = fopen(fn.c_str(), "w");	  if (f == NULL) {		printf("File Open Error\n");		return;	  }	  fprintf(f, "CircuitTimer v0.1\n");	  write(f, startTime_); // マイクロ秒	  write(f, stopTime_);	  write(f, lastLap_);	  write(f, lapCount_);	  write(f, status_);	  write(f, rider_);	  write(f, stint_);	  write(f, fuelLeft_);	  write(f, immidiateMode_);	  raceInfo_.serialize(f);	  teamInfo_.serialize(f);	  serializeArray(history_, f);	  serializeArray(riderData_, f);	  serializeArray(stintList_, f);	  fclose(f);	  if (!latest) {		// delete latest file		unlink(makeFileName(true).c_str());	  }	}	bool load(const char* filename = 0) {	  std::string fn;	  bool latest = true;	  if (filename == 0) {		fn = makeFileName(latest);	  }	  else {		fn = filename;	  }	  FILE* f = fopen(fn.c_str(), "r");	  if (f == NULL) {		printf("File Open Error(%s)\n", fn.c_str());		return false;	  }	  char buf[1024];	  fgets(buf, 1024,f);	  printf("Load :%s\n", buf);	  read(f, startTime_);	  read(f, stopTime_);	  read(f, lastLap_);	  read(f, lapCount_);	  read(f, (unsigned int&)status_);	  read(f, rider_);	  read(f, stint_);	  read(f, fuelLeft_);	  read(f, immidiateMode_);	  raceInfo_.deserialize(f);	  teamInfo_.deserialize(f);	  deserializeArray(history_, f);	  deserializeArray(riderData_, f);	  deserializeArray(stintList_, f);	  fclose(f);	  return true;	}		void setImmidateMode(bool on) {	  immidiateMode_ = on;	}	bool isImmidiateMode() const {	  return immidiateMode_;	}	void setCurrentLapTime(MicroTime t) {	  currentLapTime_ = t;	}	int32_t getCurrentStintLap() const {	  return lapCount_ - stintList_[stint_].getStartLap();	}	int32_t getStintLaps() const {	  return stintList_[stint_].laps_;	}	uint32_t getCurrentStint() const { return stint_; }	const SightingLapInfo&  getSightingLapInfo() const { return sightingLapInfo_; }  private:	std::string makeFileName(bool latest) {	  if (latest || startTime_.empty()) {		return documentPath_ + "/latest.log";	  }	  time_t t = raceInfo_.date_;	  struct tm *lt = localtime(&t);	  char buf[4096];	  snprintf(buf, 4096, "/%02d%02d%02d_%02d%02d%2d.log"			   , lt->tm_year + 1900, lt->tm_mon+1, lt->tm_mday, lt->tm_hour, lt->tm_min, lt->tm_sec);	  return documentPath_ + buf;	}			   	  	    private:	MicroTime startTime_; // マイクロ秒	MicroTime stopTime_;	MicroTime lastLap_;	uint32_t lapCount_;	StatusType status_;	uint32_t rider_;	uint32_t stint_;	double fuelLeft_;	bool immidiateMode_;	RaceInfo raceInfo_;	TeamInfo teamInfo_;	std::vector<ActionLog> history_;	std::vector<RiderInfo> riderData_;	std::vector<StintInfo> stintList_;	SightingLapInfo sightingLapInfo_;	// non save	std::string documentPath_;	MicroTime currentLapTime_;	  };	}#endif